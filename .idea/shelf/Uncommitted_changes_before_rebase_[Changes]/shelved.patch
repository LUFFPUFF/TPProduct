Index: Backend/src/main/java/com/example/domain/api/ans_api_module/template/services/answer/impl/PredefinedAnswerServiceImpl.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.example.domain.api.ans_api_module.template.services.answer.impl;\r\n\r\nimport com.example.database.model.ai_module.PredefinedAnswer;\r\nimport com.example.database.model.company_subscription_module.company.Company;\r\nimport com.example.database.repository.ai_module.PredefinedAnswerRepository;\r\nimport com.example.database.repository.company_subscription_module.CompanyRepository;\r\nimport com.example.domain.api.ans_api_module.template.mapper.PredefinedAnswerMapper;\r\nimport com.example.domain.api.ans_api_module.template.services.answer.PredefinedAnswerService;\r\nimport com.example.domain.api.ans_api_module.template.dto.request.PredefinedAnswerUploadDto;\r\nimport com.example.domain.api.ans_api_module.template.dto.response.AnswerResponse;\r\nimport jakarta.persistence.EntityNotFoundException;\r\nimport jakarta.persistence.criteria.CriteriaBuilder;\r\nimport jakarta.persistence.criteria.CriteriaQuery;\r\nimport jakarta.persistence.criteria.Predicate;\r\nimport jakarta.persistence.criteria.Root;\r\nimport jakarta.transaction.Transactional;\r\nimport lombok.RequiredArgsConstructor;\r\nimport org.springframework.data.domain.Page;\r\nimport org.springframework.data.domain.Pageable;\r\nimport org.springframework.stereotype.Service;\r\nimport org.springframework.util.StringUtils;\r\n\r\nimport java.time.LocalDateTime;\r\nimport java.time.ZoneId;\r\nimport java.util.ArrayList;\r\nimport java.util.List;\r\nimport java.util.stream.Collectors;\r\n\r\n@Service\r\n@RequiredArgsConstructor\r\npublic class PredefinedAnswerServiceImpl implements PredefinedAnswerService {\r\n\r\n    private final PredefinedAnswerRepository answerRepository;\r\n    private final CompanyRepository companyRepository;\r\n    private final PredefinedAnswerMapper answerMapper;\r\n\r\n    @Override\r\n    @Transactional\r\n    public AnswerResponse createAnswer(PredefinedAnswerUploadDto dto) {\r\n        Company company = companyRepository.findById(dto.getCompanyDto().getId())\r\n                .orElseThrow(() -> new EntityNotFoundException(\r\n                        String.format(\"Company with id %d not found\", dto.getCompanyDto().getId())));\r\n\r\n        PredefinedAnswer predefinedAnswer = answerMapper.toEntity(dto);\r\n        predefinedAnswer.setCompany(company);\r\n        predefinedAnswer.setCreatedAt(LocalDateTime.now());\r\n\r\n        PredefinedAnswer savedAnswer = answerRepository.save(predefinedAnswer);\r\n\r\n        return buildResponseFromEntity(savedAnswer);\r\n\r\n    }\r\n\r\n    @Override\r\n    @Transactional\r\n    public AnswerResponse updateAnswer(Integer id, PredefinedAnswerUploadDto dto) {\r\n        PredefinedAnswer existingAnswer = answerRepository.findById(id)\r\n                .orElseThrow(() -> new EntityNotFoundException(\r\n                        String.format(\"Answer with id %d not found\", id)));\r\n\r\n        answerMapper.updateFromDto(dto, existingAnswer);\r\n\r\n        PredefinedAnswer updatedAnswer = answerRepository.save(existingAnswer);\r\n\r\n        return buildResponseFromEntity(updatedAnswer);\r\n    }\r\n\r\n    @Override\r\n    @Transactional\r\n    public void deleteAnswer(Integer id) {\r\n        if (!answerRepository.existsById(id)) {\r\n            throw new EntityNotFoundException(String.format(\"Answer with id %d not found\", id));\r\n        }\r\n\r\n        answerRepository.deleteById(id);\r\n    }\r\n\r\n    @Override\r\n    public AnswerResponse getAnswerById(Integer id) {\r\n        return answerRepository.findById(id)\r\n                .map(this::buildResponseFromEntity)\r\n                .orElseThrow(() -> new EntityNotFoundException(String.format(\"Answer with id %d not found\", id)));\r\n    }\r\n\r\n    @Override\r\n    public Page<AnswerResponse> searchAnswers(String searchTerm, Integer companyId, Pageable pageable) {\r\n        return answerRepository.findAll(\r\n                (Root<PredefinedAnswer> root, CriteriaQuery<?> _, CriteriaBuilder cb) -> {\r\n                    List<Predicate> predicates = new ArrayList<>();\r\n\r\n                    if (companyId != null) {\r\n                        predicates.add(cb.equal(root.get(\"company\").get(\"id\"), companyId));\r\n                    }\r\n\r\n                    if (searchTerm != null && !searchTerm.trim().isEmpty()) {\r\n                        String likePattern = STR.\"%\\{searchTerm.toLowerCase()}%\";\r\n                        predicates.add(cb.or(\r\n                                cb.like(cb.lower(root.get(\"title\")), likePattern),\r\n                                cb.like(cb.lower(root.get(\"answer\")), likePattern),\r\n                                cb.like(cb.lower(root.get(\"category\")), likePattern)\r\n                        ));\r\n                    }\r\n\r\n                    return cb.and(predicates.toArray(new Predicate[0]));\r\n                },\r\n                pageable\r\n        ).map(this::buildResponseFromEntity);\r\n    }\r\n\r\n    @Override\r\n    public List<AnswerResponse> getAnswersByCategory(String category) {\r\n        if (!StringUtils.hasText(category)) {\r\n            throw new IllegalArgumentException(\"Category cannot be empty\");\r\n        }\r\n\r\n        return answerRepository.findByCategoryIgnoreCase(category).stream()\r\n                .map(this::buildResponseFromEntity)\r\n                .collect(Collectors.toList());\r\n    }\r\n\r\n    @Transactional\r\n    public int deleteByCompanyIdAndCategory(Integer companyId, String category) {\r\n        if (companyId == null || !StringUtils.hasText(category)) {\r\n            throw new IllegalArgumentException(\"Company ID and category must be provided\");\r\n        }\r\n\r\n        return answerRepository.deleteByCompanyIdAndCategory(companyId, category);\r\n    }\r\n\r\n    @Override\r\n    public List<AnswerResponse> getAllAnswers() {\r\n        return answerRepository.findAll().stream().map(this::buildResponseFromEntity).collect(Collectors.toList());\r\n    }\r\n\r\n    private AnswerResponse buildResponseFromEntity(PredefinedAnswer entity) {\r\n        return new AnswerResponse(\r\n                entity.getId(),\r\n                entity.getTitle(),\r\n                entity.getAnswer(),\r\n                entity.getCategory(),\r\n                entity.getCompany().getName(),\r\n                entity.getCreatedAt().atZone(ZoneId.systemDefault()).toInstant(),\r\n                true\r\n        );\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Backend/src/main/java/com/example/domain/api/ans_api_module/template/services/answer/impl/PredefinedAnswerServiceImpl.java b/Backend/src/main/java/com/example/domain/api/ans_api_module/template/services/answer/impl/PredefinedAnswerServiceImpl.java
--- a/Backend/src/main/java/com/example/domain/api/ans_api_module/template/services/answer/impl/PredefinedAnswerServiceImpl.java	(revision 17dae675d0a8d0f53e031e7e8a8a0a95e3cfa554)
+++ b/Backend/src/main/java/com/example/domain/api/ans_api_module/template/services/answer/impl/PredefinedAnswerServiceImpl.java	(date 1745944218148)
@@ -93,7 +93,7 @@
                     }
 
                     if (searchTerm != null && !searchTerm.trim().isEmpty()) {
-                        String likePattern = STR."%\{searchTerm.toLowerCase()}%";
+                        String likePattern = searchTerm.toLowerCase();
                         predicates.add(cb.or(
                                 cb.like(cb.lower(root.get("title")), likePattern),
                                 cb.like(cb.lower(root.get("answer")), likePattern),
